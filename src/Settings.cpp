#include "Settings.h"
#include "imgui.h"
#include <fstream>
#include <iostream>
#include <filesystem>
#include <sstream>
#include <vector>

Settings* Settings::instance = nullptr;

Settings::Settings() {
    ResetToDefaults();
}

Settings::~Settings() {
}

Settings& Settings::Instance() {
    if (!instance) {
        instance = new Settings();
        instance->LoadSettings();
    }
    return *instance;
}

void Settings::ResetToDefaults() {
    enableNotifications = true;
    enableAutoBackup = false;
    securityLevel = 2;  // High security by default
    backupRetentionDays = 30;
    enableLogging = true;
    theme = "Dark";
    themeChanged = false;
}

std::string Settings::GetSettingsFilePath() const {
    // Try multiple possible locations for the config directory
    std::vector<std::string> possiblePaths = {
        "./config/settings.conf",        // Current directory
        "../config/settings.conf",       // Parent directory (for build subdirectory)
        "../../config/settings.conf",    // Grandparent directory (for nested build dirs)
        "./config/settings.conf"         // Fallback to current directory
    };
    
    // Check if any existing config file exists
    for (size_t i = 0; i < possiblePaths.size() - 1; ++i) {
        if (std::filesystem::exists(possiblePaths[i])) {
            return possiblePaths[i];
        }
    }
    
    // If no existing file found, use the last path and create the directory
    std::string configDir = std::filesystem::path(possiblePaths.back()).parent_path();
    if (!std::filesystem::exists(configDir)) {
        std::filesystem::create_directories(configDir);
    }
    
    return possiblePaths.back();
}

bool Settings::LoadSettings() {
    std::string filePath = GetSettingsFilePath();
    
    if (!std::filesystem::exists(filePath)) {
        std::cout << "Settings file not found, using defaults" << std::endl;
        return SaveSettings(); // Create default settings file
    }
    
    // Reset to defaults first to ensure clean state
    ResetToDefaults();
    
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cout << "Could not open settings file: " << filePath << std::endl;
        return false;
    }
    
    std::string line;
    while (std::getline(file, line)) {
        if (!ParseSettingsLine(line)) {
            std::cout << "Warning: Could not parse settings line: " << line << std::endl;
        }
    }
    
    file.close();
    std::cout << "Settings loaded successfully from: " << filePath << std::endl;
    return true;
}

bool Settings::ParseSettingsLine(const std::string& line) {
    // Skip empty lines and comments
    if (line.empty() || line[0] == '#') {
        return true;
    }
    
    size_t equalPos = line.find('=');
    if (equalPos == std::string::npos) {
        return false;
    }
    
    std::string key = line.substr(0, equalPos);
    std::string value = line.substr(equalPos + 1);
    
    // Trim whitespace
    key.erase(0, key.find_first_not_of(" \t"));
    key.erase(key.find_last_not_of(" \t") + 1);
    value.erase(0, value.find_first_not_of(" \t"));
    value.erase(value.find_last_not_of(" \t") + 1);
    
    // Parse different setting types
    if (key == "enableNotifications") {
        enableNotifications = (value == "true" || value == "1");
    } else if (key == "enableAutoBackup") {
        enableAutoBackup = (value == "true" || value == "1");
    } else if (key == "securityLevel") {
        try {
            securityLevel = std::stoi(value);
            if (securityLevel < 1 || securityLevel > 3) {
                securityLevel = 2; // Default to High
            }
        } catch (const std::exception&) {
            securityLevel = 2;
        }
    } else if (key == "backupRetentionDays") {
        try {
            backupRetentionDays = std::stoi(value);
            if (backupRetentionDays < 1) {
                backupRetentionDays = 30;
            }
        } catch (const std::exception&) {
            backupRetentionDays = 30;
        }
    } else if (key == "enableLogging") {
        enableLogging = (value == "true" || value == "1");
    } else if (key == "theme") {
        if (value == "Dark" || value == "Light" || value == "Auto") {
            theme = value;
        } else {
            theme = "Dark";
        }
    } else {
        return false; // Unknown key
    }
    
    return true;
}

bool Settings::SaveSettings() {
    std::string filePath = GetSettingsFilePath();
    
    std::ofstream file(filePath);
    if (!file.is_open()) {
        std::cout << "Could not create settings file: " << filePath << std::endl;
        return false;
    }
    
    // Write header
    file << "# PQC Wallet Settings Configuration\n";
    file << "# This file is automatically generated\n";
    file << "# Boolean values: true/false or 1/0\n\n";
    
    // Write settings
    file << "enableNotifications=" << (enableNotifications ? "true" : "false") << "\n";
    file << "enableAutoBackup=" << (enableAutoBackup ? "true" : "false") << "\n";
    file << "securityLevel=" << securityLevel << "\n";
    file << "backupRetentionDays=" << backupRetentionDays << "\n";
    file << "enableLogging=" << (enableLogging ? "true" : "false") << "\n";
    file << "theme=" << theme << "\n";
    
    file.close();
    
    // Set restrictive permissions for the config file
    try {
        std::filesystem::permissions(filePath, 
            std::filesystem::perms::owner_read | std::filesystem::perms::owner_write,
            std::filesystem::perm_options::replace);
    } catch (const std::exception& e) {
        std::cout << "Warning: Could not set restrictive permissions on settings file: " << e.what() << std::endl;
    }
    
    std::cout << "Settings saved successfully to: " << filePath << std::endl;
    return true;
}

void Settings::ApplyTheme() const {
    if (theme == "Light") {
        ImGui::StyleColorsLight();
    } else if (theme == "Dark") {
        ImGui::StyleColorsDark();
    } else if (theme == "Auto") {
        // For Auto, we'll default to Dark for now
        // In a real implementation, you might check system theme
        ImGui::StyleColorsDark();
    } else {
        // Default fallback
        ImGui::StyleColorsDark();
    }
    
    // Apply custom style settings regardless of theme
    ImGuiStyle& style = ImGui::GetStyle();
    style.WindowRounding = 5.0f;
    style.FrameRounding = 3.0f;
    style.ScrollbarRounding = 3.0f;
    style.GrabRounding = 3.0f;
    style.WindowBorderSize = 1.0f;
    style.FrameBorderSize = 1.0f;
    
    // Theme-specific customizations for better contrast
    ImVec4* colors = style.Colors;
    
    if (theme == "Light") {
        // Light theme customizations with better contrast
        colors[ImGuiCol_WindowBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.95f);
        colors[ImGuiCol_MenuBarBg] = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
        colors[ImGuiCol_Header] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        colors[ImGuiCol_HeaderHovered] = ImVec4(0.75f, 0.75f, 0.75f, 1.0f);
        colors[ImGuiCol_HeaderActive] = ImVec4(0.65f, 0.65f, 0.65f, 1.0f);
        
        // Improve text contrast for light theme - ALL TEXT SHOULD BE DARK
        colors[ImGuiCol_Text] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);  // Black text for all controls
        colors[ImGuiCol_TextDisabled] = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);  // Gray disabled text
        colors[ImGuiCol_TextSelectedBg] = ImVec4(0.3f, 0.6f, 1.0f, 0.35f);  // Selection background
        
        // Child window backgrounds (for sections)
        colors[ImGuiCol_ChildBg] = ImVec4(0.92f, 0.92f, 0.92f, 0.8f);
        
        // Button colors for light theme - adjusted for black text
        colors[ImGuiCol_Button] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        colors[ImGuiCol_ButtonHovered] = ImVec4(0.75f, 0.75f, 0.75f, 1.0f);
        colors[ImGuiCol_ButtonActive] = ImVec4(0.65f, 0.65f, 0.65f, 1.0f);
        
        // Border colors
        colors[ImGuiCol_Border] = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
        colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        
        // Frame backgrounds (input fields, etc.)
        colors[ImGuiCol_FrameBg] = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        colors[ImGuiCol_FrameBgHovered] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        colors[ImGuiCol_FrameBgActive] = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        
        // Checkbox and radio button colors
        colors[ImGuiCol_CheckMark] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);  // Black checkmarks
        
        // Slider colors
        colors[ImGuiCol_SliderGrab] = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        colors[ImGuiCol_SliderGrabActive] = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        
        // Combo box colors
        colors[ImGuiCol_FrameBg] = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        colors[ImGuiCol_FrameBgHovered] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        colors[ImGuiCol_FrameBgActive] = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        
        // Popup background
        colors[ImGuiCol_PopupBg] = ImVec4(0.95f, 0.95f, 0.95f, 0.98f);
        
        // Tab colors
        colors[ImGuiCol_Tab] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        colors[ImGuiCol_TabHovered] = ImVec4(0.75f, 0.75f, 0.75f, 1.0f);
        colors[ImGuiCol_TabActive] = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        colors[ImGuiCol_TabUnfocused] = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
        
    } else {
        // Dark theme customizations
        colors[ImGuiCol_WindowBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.95f);
        colors[ImGuiCol_MenuBarBg] = ImVec4(0.12f, 0.12f, 0.12f, 1.0f);
        colors[ImGuiCol_Header] = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        colors[ImGuiCol_HeaderHovered] = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        colors[ImGuiCol_HeaderActive] = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        
        // Ensure good text contrast for dark theme - ALL TEXT SHOULD BE LIGHT
        colors[ImGuiCol_Text] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White text for all controls
        colors[ImGuiCol_TextDisabled] = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);  // Light gray disabled text
        colors[ImGuiCol_TextSelectedBg] = ImVec4(0.3f, 0.6f, 1.0f, 0.35f);  // Selection background
        
        // Child window backgrounds (for sections)
        colors[ImGuiCol_ChildBg] = ImVec4(0.15f, 0.15f, 0.15f, 0.8f);
        
        // Button colors for dark theme - light enough to contrast with black text
        colors[ImGuiCol_Button] = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
        colors[ImGuiCol_ButtonHovered] = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        colors[ImGuiCol_ButtonActive] = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
        
        // Border colors    
        colors[ImGuiCol_Border] = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        
        // Frame backgrounds (input fields, etc.)
        colors[ImGuiCol_FrameBg] = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        colors[ImGuiCol_FrameBgHovered] = ImVec4(0.25f, 0.25f, 0.25f, 1.0f);
        colors[ImGuiCol_FrameBgActive] = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        
        // Checkbox and radio button colors
        colors[ImGuiCol_CheckMark] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White checkmarks
        
        // Slider colors
        colors[ImGuiCol_SliderGrab] = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
        colors[ImGuiCol_SliderGrabActive] = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        
        // Popup background
        colors[ImGuiCol_PopupBg] = ImVec4(0.1f, 0.1f, 0.1f, 0.98f);
        
        // Tab colors
        colors[ImGuiCol_Tab] = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        colors[ImGuiCol_TabHovered] = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        colors[ImGuiCol_TabActive] = ImVec4(0.25f, 0.25f, 0.25f, 1.0f);
        colors[ImGuiCol_TabUnfocused] = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
        colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
    }
    
    // Note: For button text to always be black, we will need to use 
    // ImGui::PushStyleColor/PopStyleColor in the UI code for each button
    // since ImGui doesn't have separate button text colors
}

void Settings::NotifyThemeChanged() const {
    // Set flag for main loop to detect theme change
    themeChanged = true;
    
    // Force immediate theme application
    ApplyTheme();
    
    // Additional actions could be added here to notify specific UI components
    // For now, ApplyTheme() should be sufficient since ImGui recalculates 
    // colors on the next frame
    std::cout << "Theme change notification sent - UI will update on next frame" << std::endl;
}

Settings::ThemeColors Settings::GetThemeColors() const {
    ThemeColors colors;
    
    if (theme == "Light") {
        // Light theme colors - darker colors for better contrast on light background
        // Primary text: Dark gray/black
        colors.primaryText[0] = 0.1f; colors.primaryText[1] = 0.1f; colors.primaryText[2] = 0.1f; colors.primaryText[3] = 1.0f;
        
        // Secondary text: Medium gray
        colors.secondaryText[0] = 0.4f; colors.secondaryText[1] = 0.4f; colors.secondaryText[2] = 0.4f; colors.secondaryText[3] = 1.0f;
        
        // Accent text: Dark blue
        colors.accentText[0] = 0.2f; colors.accentText[1] = 0.4f; colors.accentText[2] = 0.8f; colors.accentText[3] = 1.0f;
        
        // Success text: Dark green
        colors.successText[0] = 0.1f; colors.successText[1] = 0.6f; colors.successText[2] = 0.1f; colors.successText[3] = 1.0f;
        
        // Warning text: Dark orange/amber
        colors.warningText[0] = 0.8f; colors.warningText[1] = 0.5f; colors.warningText[2] = 0.0f; colors.warningText[3] = 1.0f;
        
        // Error text: Dark red
        colors.errorText[0] = 0.8f; colors.errorText[1] = 0.1f; colors.errorText[2] = 0.1f; colors.errorText[3] = 1.0f;
        
        // Info text: Dark cyan/teal
        colors.infoText[0] = 0.1f; colors.infoText[1] = 0.6f; colors.infoText[2] = 0.7f; colors.infoText[3] = 1.0f;
        
    } else {
        // Dark theme colors - brighter colors for contrast on dark background
        // Primary text: Light gray/white
        colors.primaryText[0] = 0.9f; colors.primaryText[1] = 0.9f; colors.primaryText[2] = 0.9f; colors.primaryText[3] = 1.0f;
        
        // Secondary text: Medium gray
        colors.secondaryText[0] = 0.7f; colors.secondaryText[1] = 0.7f; colors.secondaryText[2] = 0.7f; colors.secondaryText[3] = 1.0f;
        
        // Accent text: Light blue
        colors.accentText[0] = 0.7f; colors.accentText[1] = 0.9f; colors.accentText[2] = 1.0f; colors.accentText[3] = 1.0f;
        
        // Success text: Light green
        colors.successText[0] = 0.5f; colors.successText[1] = 0.8f; colors.successText[2] = 0.5f; colors.successText[3] = 1.0f;
        
        // Warning text: Light yellow
        colors.warningText[0] = 0.8f; colors.warningText[1] = 0.8f; colors.warningText[2] = 0.5f; colors.warningText[3] = 1.0f;
        
        // Error text: Light red
        colors.errorText[0] = 1.0f; colors.errorText[1] = 0.4f; colors.errorText[2] = 0.4f; colors.errorText[3] = 1.0f;
        
        // Info text: Light cyan
        colors.infoText[0] = 0.6f; colors.infoText[1] = 0.8f; colors.infoText[2] = 0.9f; colors.infoText[3] = 1.0f;
    }
    
    return colors;
}

void Settings::PushBlackButtonText() {
    // Push black text color for buttons regardless of theme
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
}

void Settings::PopBlackButtonText() {
    // Pop the black text color
    ImGui::PopStyleColor(1);
}
